\CarpetX\space provides a way of setting up standard boundary conditions and symmetry conditions (to be applied on grid boundaries) via parameter files and grid function tags. More complex boundary conditions can be implemented by users but doing so is not often an easy task due to how \texttt{AMReX} works internally.

\subsection{Boundary conditions via parameters}

The following boundary condition types can be specified:

\begin{enumerate}
    \item \texttt{"none"}: Don't apply any boundary condition to the grid. This is the default setting for all boundaries.
    \item \texttt{"dirichlet"}: Dirichlet boundary conditions.
    \item \texttt{"linear extrapolation"}: Linearly extrapolate interior values to boundary values.
    \item \texttt{"neumann"}: Neumann boundary conditions.
    \item \texttt{"robin"}: Robin boundary conditions.
\end{enumerate}

Remember that, given a function $f(x,y,z)$ that satisfies a given PDE in a domain $\Omega \subset \mathbb{R}^n$ whose boundary is denoted by $\partial\Omega$, a Dirichlet boundary condition imposes that
%
\begin{equation}
  f(x,y,z) = g \quad \forall (x,y,z) \in \partial \Omega,
  \label{eq:dirichlet}
\end{equation}
%
a Neumann boundary condition imposes that
%
\begin{equation}
  \frac{\partial f}{\partial \mathbf{n}} = g \quad \forall (x,y,z) \in \partial \Omega,
  \label{eq:neumann}
\end{equation}
%
where $\mathbf{n}$ is the normal to the boundary $\partial \Omega$ and a Robin boundary condition imposes that
%
\begin{equation}
  a f + b \frac{\partial f}{\partial \mathbf{n}} = g \quad \forall (x,y,z) \in \partial \Omega.
  \label{eq:robin}
\end{equation}

The type of boundary condition in all 6 grid faces can be configured independently via the parameters described in Tab.~\ref{tab:boundary_settings}.

\begin{table}[ht]
    \centering
    \begin{tabular}{cc}
    Parameter                   & Description                             \\\hline\hline
    \texttt{boundary\_x}        & Boundary condition at lower $x$ boundary\\
    \texttt{boundary\_upper\_x} & Boundary condition at upper $x$ boundary\\
    \texttt{boundary\_y}        & Boundary condition at lower $y$ boundary\\
    \texttt{boundary\_upper\_y} & Boundary condition at upper $y$ boundary\\
    \texttt{boundary\_z}        & Boundary condition at lower $z$ boundary\\
    \texttt{boundary\_upper\_z} & Boundary condition at upper $z$ boundary\\\hline\hline
    \end{tabular}
    \caption{Parameters controlling boundary condition types in \CarpetX.}
    \label{tab:boundary_settings}
\end{table}

  Once boundary types are chosen, they are applied to all grid functions. Users may override the global configuration for a specific set of grid function in which different boundary conditions should be applied to. This is done by passing a list of space (or new line) separated strings to the appropriate parameter, depending on which boundary condition(s) should be overridden. These parameters are of the form
%
  \begin{center}
    \texttt{CarpetX::<boundary condition name>\_<direction>\_vars = "..."}
  \end{center}
%
where \texttt{<boundary condition name>} is one of
%
\begin{itemize}
  \item \texttt{dirichlet}
  \item \texttt{linear\_extrapolation}
  \item \texttt{neumann}
  \item \texttt{robin}
\end{itemize}
%
and \texttt{<direction>} is one of
\begin{itemize}
  \item \texttt{x}
  \item \texttt{y}
  \item \texttt{z}
  \item \texttt{upper\_x}
  \item \texttt{upper\_y}
  \item \texttt{upper\_z}
\end{itemize}

In order to set the actual values of Dirichlet, Neumann and Robin boundary conditions, users can specify values via the \texttt{TAGS} mechanism in \texttt{interface.ccl}, detailed in Sec.~\ref{sec:tags}. Note that it is only possible to set the quantity $g$ in Eqs~\eqref{eq:dirichlet}-\eqref{eq:robin}. The syntax is as follows

\begin{lstlisting}[language=bash]
  # For Dirichlet BCs
  CCTK_<type> <group-name> TAGS='dirichlet_values={1.0}'
  {
    ...
  } "A group of variables"

  # For Neumman BCs
  CCTK_<type> <group-name> TAGS='neumann_values={1.0}'
  {
    ...
  } "A group of variables"

  # For Robin BCs
  CCTK_<type> <group-name> TAGS='robin_values={1.0}'
  {
    ...
  } "A group of variables"
\end{lstlisting}

If a variable group contains multiple variables or multiple boundary conditions, simply append the boundary values to the brace enclose list of boundary values and add another boundary condition as a tag. For example, consider the 3-metric variable group declared in the \texttt{ADMBaseX} thorn bundled with \CarpetX, which consists of 6 grid functions each with their own Dirichlet and Robin boundary condition values:

\begin{lstlisting}[language=bash]
  CCTK_REAL metric TYPE=gf TAGS='dirichlet_values={1.0 0.0 0.0   1.0 0.0   1.0} robin_values={1.0 0.0 0.0   1.0 0.0   1.0} ...'
  {
    gxx gxy gxz gyy gyz gzz
  } "ADM 3-metric g_ij"
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Symmetry boundary conditions}

\CarpetX\space supports two types of symmetry boundary conditions: Reflections and periodicity. Each of these conditions can be set individually for each grid face as with boundary conditions. To Set reflective symmetry conditions, the parameters in Tab.~\ref{tab:reflection_params} are available. To set periodicity, the parameters in Tab.~\ref{tab:periodic_params} are provided.

\begin{table}[ht]
  \centering
  \begin{tabular}{cc}
  Parameter                     & Description                             \\\hline\hline
  \texttt{reflection\_x}        & Reflection symmetry at lower $x$ boundary\\
  \texttt{reflection\_upper\_x} & Reflection symmetry at upper $x$ boundary\\
  \texttt{reflection\_y}        & Reflection symmetry at lower $y$ boundary\\
  \texttt{reflection\_upper\_y} & Reflection symmetry at upper $y$ boundary\\
  \texttt{reflection\_z}        & Reflection symmetry at lower $z$ boundary\\
  \texttt{reflection\_upper\_z} & Reflection symmetry at upper $z$ boundary\\\hline\hline
  \end{tabular}
  \caption{Parameters controlling reflection symmetry in \CarpetX.}
  \label{tab:reflection_params}
\end{table}

\begin{table}[ht]
  \centering
  \begin{tabular}{cc}
  Parameter            & Description          \\\hline\hline
  \texttt{periodic\_x} & Periodic $x$ boundary\\
  \texttt{periodic\_x} & periodic $y$ boundary\\
  \texttt{periodic\_y} & Periodic $z$ boundary\\\hline\hline
  \end{tabular}
  \caption{Parameters controlling periodicity in \CarpetX.}
  \label{tab:periodic_params}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Custom boundary conditions}

The recommended way o applying custom boundary conditions is to write them to the RHS of the evolution system. Let us once again consider the function that computes the RHS of Eqs.~\eqref{eq:toy_loop_0}-\eqref{eq:toy_loop_1} presented in Sec.~\ref{sec:loops} modified to compute boundary conditions:

\begin{lstlisting}
extern "C" void LoopExample_RHS(CCTK_ARGUMENTS) {
  DECLARE_CCTK_ARGUMENTS_LoopExample_RHS;
  DECLARE_CCTK_PARAMETERS;

  // The grid variable is implicitly defined via the CCTK macros
  // A 0/1 in template parameters indicate that a grid is vertex/cell centered
  grid.loop_int<0, 0, 0>(
    grid.nghostzones,

    // The loop lambda
    [=] (const Loop::PointDesc &p) {
      using std::pow;

      // Instead of computing values for each direction expression
      // explicitly we will use a loop to save us from some typing
      // ddu will store the partial results for each direction
      Arith::vect<CCTK_REAL, dim> ddu;
      
      // Loop over directions
      for (int d = 0; d < dim; ++d) {
        
        // Boundary associated with xmin ymin and zmin
        if (p.BI[d] < 0) {
          ddu[d] = 0;
        }
        // Boundary associated with xmax ymax and zmax
        else if (p.BI[d] > 0) {
          ddu[d] = 0;
        }
        // interior
        else {
          ddu[d] = (u(p.I - p.DI[d]) - 2 * u(p.I) + u(p.I + p.DI[d])) /
                    pow(p.DX[d], 2);
        }
      }

      u_rhs(p.I) = rho(p.I);
      rho_rhs(p.I) = ddu[0] + ddu[1] + ddu[2];

    } // Ending of the loop lambda
  ); // Ending of the loop_int call
}
\end{lstlisting}

Instead of computing derivatives and boundaries for each direction explicitly, we use a loop over each direction, written on line 20. The \texttt{if} branches on lines 23-25 and 27-29 set the values of the RHS of the system in the boundaries associated with the \texttt{xyz\_min} values and \texttt{xyz\_max} values, respectively. In these case, we are setting boundary values to $0$, but users would use whatever boundary condition they require. The takeaway message of this example is to note how one can \textit{access} boundary points, instead of what to write to those points.