\subsection{\texttt{configuration.ccl}}

\todo{Talk about requirements for bringing carpetx things in for accessing the APIs}

\subsection{\texttt{interface.ccl}}

Interface files declare a thorn's \Cactus-facing interface by defines grid functions, variables and others (see Sec.~C1.2 of the \Cactus user guide for more details). Drivers, such as \CarpetX, are able to parse information in \texttt{interface.ccl} declarations in order to have its behavior customized. 

\subsection{Types}

\todo{Are types part of the flesh or are they a carpetx thing?}

\subsection{Centering}

The centering of a grid function is declared via \texttt{CENTERING={<centering-code>}}, where \texttt{<centering-code>} is a three-letter code containing any combination of either \texttt{c} or \texttt{v}, representing cell centering and vertex centering, respectively. For example, to declare a group of variables as being cell centered, one would use
%
\begin{lstlisting}
  CCTK_<type> <group-name> CENTERING={ccc}
  {
    ...
  } "A group of variables"
\end{lstlisting}

Similarly, for a vertex centered group one would use
%
\begin{lstlisting}
  CCTK_<type> <group-name> CENTERING={vvv}
  {
    ...
  } "A group of variables"
\end{lstlisting}

Note that it is possible to mix centering indexes. For example, to have a quantity centered at faces in the x direction, one would write
%
\begin{lstlisting}
  CCTK_<type> <group-name> CENTERING={cvv}
  {
    ...
  } "A group of variables"
\end{lstlisting}

Not also that if no \texttt{CENTERING} is specified, \CarpetX\space assumes that the variable group is vertex centered in all directions.

Finally, it is very important to match the centering description in interface files with the description passed to loop API template arguments. See Sec.~\ref{sec:loops} for details.

\subsubsection{Tags}

Tags are declared in interface statements with the \texttt{TAGS=<tags>} syntax. The \texttt{<tags>} declaration consists of a single quote string (marked by \texttt{'}) with space separated key-value pars of the form \texttt{key="value"}. For example, a tagged interface declaration will be similar to the following
%
\begin{lstlisting}[language=bash]
  CCTK_<type> <group-name> TAGS='key_1="key1" key_2="key2" ...'
  {
    ...
  } "A group of variables"
\end{lstlisting}

We will now list the tags supported by \CarpetX\space and describe their usage.

\begin{enumerate}
  \item \texttt{rhs}: Marks a group of grid variables as the RHS (right-hand side) of a system. \texttt{ODESolvers} uses this information to perform time steps and update a state vector (See Sec.~\ref{sec:odesolvers} for more information). For example, in
  %
  \begin{lstlisting}[language=bash]
    CCTK_<type> state_vector TAGS='rhs="right_hand_side"'
    {
      ...
    } "A group of variables representing the PDE system state"

    CCTK_<type> right_hand_side
    {
      ...
    } "A group of variables representing the PDE RHS"
  \end{lstlisting}
  %
  the \texttt{rhs="right\_hand\_side"} tag indicates that the group named \texttt{state\_vector} has a corresponding RHS group named \texttt{right\_hand\_side}.

  \begin{lstlisting}[language=bash]
    CCTK_<type> state_vector TAGS='rhs="right_hand_side"'
    {
      ...
    } "A group of variables representing the PDE system state"
  \end{lstlisting}
  
  \item \texttt{dependents}: Indicates that the groups of variables contained on this tag must be marked as invalid if there are any changes to the group being declared. For example, in
  %
  \begin{lstlisting}[language=bash]
    CCTK_<type> parent_group TAGS='dependents="child1 child2"'
    {
      ...
    } "A group of real variables"
  \end{lstlisting}
  %
  the tag \texttt{dependents="child1 child2"} indicates that \texttt{parent\_group} has two dependent groups, \texttt{child1} and \texttt{child2}. Whenever \CarpetX\space writes to variables in \texttt{parent\_group}, variables in \texttt{child1} and \texttt{child2} are marked as invalid and cannot be read from unless written to again.
  
  \item \texttt{checkpoint}: Indicates that a variable group must be saved as a simulation checkpoint. \Cactus\space and \CarpetX\space can then later recover the saved checkpoint variables and restore the simulation state to continue evolution from there. Usually, only state vectors are checkpointed (See Chap. A3 of the \Cactus user manual for further details). For example, in
  %
  \begin{lstlisting}[language=bash]
    CCTK_<type> state_vector TAGS='checkpoint="yes"'
    {
      ...
    } "A group of real variables describing the simulation state"

    CCTK_<type> right_hand_side TAGS='checkpoint="no"'
    {
      ...
    } "A group of real variables describing the simulation RHS"
  \end{lstlisting}
  %
  the simulation state, represented by the \texttt{state\_vector} group is checkpointed, while the \texttt{right\_hand\_side} group is not.
\end{enumerate}

\subsection{\texttt{schedule.ccl}}

\todo{Talk about important new schedule bins and the read/write safeguards on schedules.}

\subsection{Preprocessor macros}

\todo{Talk about new macros and new macro features. The text below is mostly ok, but needs to be adapted}

The macros \texttt{DECLARE\_CCTK\_ARGUMENTSX\_WaveToyX\_RHS}, \texttt{CCTK\_ARGUMENTS} and \texttt{DECLARE\_CCTK\_PARAMETERS} allow the thorn writer to access parameters and grid functions declared in the thorn's \texttt{.ccl} files. Note that \Cactus\space now supports the \texttt{DECLARE\_CCTK\_ARGUMENTSX\_FUNC\_NAME} macro, where \texttt{FUNC\_NAME} is the name of a grid function declared in the \texttt{schedule.ccl} file. These macros restrict the access of a function to it's schedule-declared grid functions. More importantly, it provides a variable called \texttt{grid} which can be used to access the functionalities of the \texttt{Loop} API.