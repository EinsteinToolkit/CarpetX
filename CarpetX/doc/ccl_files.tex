CCL files are used to define cactus thorns and customize its behavior. In this section, we shall discuss the additions that \CarpetX\space brigs to these files, but we shall not teach users how to write them from scratch. In order to learn more, refer to Sec.~C of the \Cactus\space user guide provided in the \texttt{doc} folder of all distributions.

\subsection{\texttt{configuration.ccl} and \texttt{schedule.ccl}}

\CarpetX\space does not modify these files radically. Users may need to require certain thorns explicitly in \texttt{configuration.ccl} files when using \CarpetX\space APIs or schedule functions at specific bins provided by thorns in the \CarpetX\space arrangement. These thorn-specific additions are documented in the thorn's section of this text.

An important point to note is that \CarpetX\space strongly enforces read, write and location statement correctness at runtime and compile time. This means that one is not able to write to a variable declared as \texttt{READ} or read past region. \CarpetX\space also marks points in regions as valid or invalid and impedes user of reading from invalid data points. These extra measures help users prevent common memory and region access bugs. In their \texttt{C++} code, users should always use the \texttt{DECLARE\_CCTK\_ARGUMENTSX\_<scheduled function name>} macro to ensure that only the objects declared in the function's schedule block in \texttt{schedule.ccl} are brought into scope, as well as other objects necessary for working with \CarpetX.

\subsection{\texttt{interface.ccl}}

The most significant additions were made to interface files. In these files, users declare a thorn's \Cactus-facing interface by defines grid functions, variables and others (see Sec.~C1.2 of the \Cactus user guide for more details). Drivers, such as \CarpetX, are able to parse information in \texttt{interface.ccl} declarations in order to have its behavior customized. 

\subsubsection{Centering}

The centering of a grid function is declared via \texttt{CENTERING={<centering-code>}}, where \texttt{<centering-code>} is a three-letter code containing any combination of either \texttt{c} or \texttt{v}, representing cell centering and vertex centering, respectively. For example, to declare a group of variables as being cell centered, one would use
%
\begin{lstlisting}
  CCTK_<type> <group-name> CENTERING={ccc}
  {
    ...
  } "A group of variables"
\end{lstlisting}

Similarly, for a vertex centered group one would use
%
\begin{lstlisting}
  CCTK_<type> <group-name> CENTERING={vvv}
  {
    ...
  } "A group of variables"
\end{lstlisting}

Note that it is possible to mix centering indexes. For example, to have a quantity centered at faces in the x direction, one would write
%
\begin{lstlisting}
  CCTK_<type> <group-name> CENTERING={cvv}
  {
    ...
  } "A group of variables"
\end{lstlisting}

Not also that if no \texttt{CENTERING} is specified, \CarpetX\space assumes that the variable group is vertex centered in all directions.

Finally, it is very important to match the centering description in interface files with the description passed to loop API template arguments. See Sec.~\ref{sec:loops} for details.

\subsubsection{Tags}

Tags are declared in interface statements with the \texttt{TAGS=<tags>} syntax. The \texttt{<tags>} declaration consists of a single quote string (marked by \texttt{'}) with space separated key-value pars of the form \texttt{key="value"}. For example, a tagged interface declaration will be similar to the following
%
\begin{lstlisting}[language=bash]
  CCTK_<type> <group-name> TAGS='key_1="key1" key_2="key2" ...'
  {
    ...
  } "A group of variables"
\end{lstlisting}

We will now list the tags supported by \CarpetX\space and describe their usage.

\begin{enumerate}
  \item \texttt{rhs}: Marks a group of grid variables as the RHS (right-hand side) of a system. \texttt{ODESolvers} uses this information to perform time steps and update a state vector (See Sec.~\ref{sec:odesolvers} for more information). For example, in
  %
  \begin{lstlisting}[language=bash]
    CCTK_<type> state_vector TAGS='rhs="right_hand_side"'
    {
      ...
    } "A group of variables representing the PDE system state"

    CCTK_<type> right_hand_side
    {
      ...
    } "A group of variables representing the PDE RHS"
  \end{lstlisting}
  %
  the \texttt{rhs="right\_hand\_side"} tag indicates that the group named \texttt{state\_vector} has a corresponding RHS group named \texttt{right\_hand\_side}.

  \begin{lstlisting}[language=bash]
    CCTK_<type> state_vector TAGS='rhs="right_hand_side"'
    {
      ...
    } "A group of variables representing the PDE system state"
  \end{lstlisting}
  
  \item \texttt{dependents}: Indicates that the groups of variables contained on this tag must be marked as invalid if there are any changes to the group being declared. For example, in
  %
  \begin{lstlisting}[language=bash]
    CCTK_<type> parent_group TAGS='dependents="child1 child2"'
    {
      ...
    } "A group of real variables"
  \end{lstlisting}
  %
  the tag \texttt{dependents="child1 child2"} indicates that \texttt{parent\_group} has two dependent groups, \texttt{child1} and \texttt{child2}. Whenever \CarpetX\space writes to variables in \texttt{parent\_group}, variables in \texttt{child1} and \texttt{child2} are marked as invalid and cannot be read from unless written to again.
  
  \item \texttt{checkpoint}: Indicates that a variable group must be saved as a simulation checkpoint. \Cactus\space and \CarpetX\space can then later recover the saved checkpoint variables and restore the simulation state to continue evolution from there. Usually, only state vectors are checkpointed (See Chap. A3 of the \Cactus user manual for further details). For example, in
  %
  \begin{lstlisting}[language=bash]
    CCTK_<type> state_vector TAGS='checkpoint="yes"'
    {
      ...
    } "A group of real variables describing the simulation state"

    CCTK_<type> right_hand_side TAGS='checkpoint="no"'
    {
      ...
    } "A group of real variables describing the simulation RHS"
  \end{lstlisting}
  %
  the simulation state, represented by the \texttt{state\_vector} group is checkpointed, while the \texttt{right\_hand\_side} group is not.
\end{enumerate}