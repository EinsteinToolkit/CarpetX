In \CarpetX\space loops over grid elements are not written explicitly. Operations that are to be executed for every grid element (cells, edges or points) are specified via \texttt{C++} \href{https://en.cppreference.com/w/cpp/language/lambda}{\textit{lambda functions}}, also known as closures or anonymous functions.

These objects behave like regular \texttt{C++} functions, but can be defined \textit{inline}, that is, on the body of a function or as an argument to another function.

An important concept to grasp with lambda function is \textit{captures}. If a lambda (let us call this the child function) is defined in the body of an outer function (let us call this the parent function), the child can access variables defined in the parent function, provided that these variables are \textit{captured}. The two most relevant modes of capture while using \CarpetX\space are \textit{capture by reference} (denoted with the \texttt{\&} sign in the square brackets denoting the start of the lambda) and \textit{capture by value} (denoted by an \texttt{=} sign inside the square brackets of the lambda declaration).

When running on GPUs, captures by value are \textit{required} and captures by reference are \textit{forbidden}. This is because data must be copied from host (CPU side) memory to device (GPU side) memory in order to be executed.

The API for writing loops in \CarpetX\space is provided by the \texttt{Loop} thorn. To use it, one must add
%
\begin{lstlisting}[language=Bash]
    REQUIRES Loop
\end{lstlisting}
%
to the thorn's \texttt{configuration.ccl} file and
%
\begin{lstlisting}[language=Bash]
    INHERITS: CarpetX   
    USES INCLUDE HEADER: loop.hxx        # For using CarpetX on CPUs
    USES INCLUDE HEADER: loop_device.hxx # For using CarpetX on GPUs
\end{lstlisting}
%
to the thorn's \texttt{interface.ccl} file. Furthermore, one must include the \texttt{Loop} API header file in all source files where the API is needed by adding
%
\begin{lstlisting}
    #include <loop.hxx>
    #include <loop_device.hxx>
\end{lstlisting}
%
to the beginning of the source file.

\todo{Figure out whether we need both of these header files}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loop regions}
\label{sec:loop_regions}

Before actually writing any code that iterates over grid elements, one must choose \textit{which} elements are to be iterated over. We shall refer to the set of points in the grid hierarchy that will be iterated over when a loop is executed as a \textit{Loop region}. The following regions are defined in the \texttt{Loop} API:

\begin{enumerate}
    \item All: This region refers to all points contained in the grid. Denoted in code by the \texttt{all} suffix.
    
    \item Interior: This region refers to the interior of the grid. Denoted in code by the \texttt{int} prefix.
    
    \item Outermost interior: This region refers to the outermost "boundary" points in the interior. They correspond to points that are shifted inwards by = cctk\_nghostzones[3] from those that CarpetX identifies as boundary points. From the perspective of CarpetX (or AMReX), these do not belong in the outer boundary, but rather the interior. This excludes ghost faces, but includes ghost edges/corners on non-ghost faces. Loop over faces first, then edges, then corners. Denoted in code by the \texttt{outermost\_int} suffix.
\end{enumerate}

\todo{Picture of grid regions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loop methods}
\label{sec:loop_methods}

Loop API functions are methods of the \texttt{GridDescBase} or \texttt{GridDescBaseDevice} classes which contain functions for looping over grid elements on the CPU or GPU, respectively.\todo{Is this correct? Do we need these two classes? Can we make it with on}. The macro \texttt{DECLARE\_CCTK\_ARGUMENTSX\_FUNCTION\_NAME} provides a variable called \texttt{grid}, which is an instance of either of these classes. The name of each looping method is formed according to
%
\begin{center}
    \texttt{loop\_} + \textless loop region\textgreater + [\_\texttt{device}]
\end{center}

For example, to loop over boundaries using the CPU one would call
%
\begin{lstlisting}
    grid.loop_bnd<...>(...);
\end{lstlisting}
%
To obtain a GPU equivalent version, one would simply append \texttt{\_device} to the function name. Thus, for example, to loop over the interior using a GPU, one would call 

\begin{lstlisting}
    grid.loop_int_device<...>(...);
\end{lstlisting}

Let us now look at the required parameter of loop methods. The typical signature is as follows

\begin{lstlisting}
  template <int CI, int CJ, int CK, ..., typename F>
  void loop_REG_PU(const vect<int, dim> &group_nghostzones, const F &f);
\end{lstlisting}

The template parameters meanings are as follows:

\begin{enumerate}
  \item \texttt{CI}: Centering index for the first grid direction. Must be set explicitly and be either 0 or 1. 0 means that this direction will be looped over grid vertices, while 1 means that it will be looped over cell centers.
  \item \texttt{CJ}: Centering index for the second grid direction. Must be set explicitly and be either 0 or 1. 0 means that this direction will be looped over grid vertices, while 1 means that it will be looped over cell centers.
  \item \texttt{CK}: Centering index for the third grid direction. Must be set explicitly and be either 0 or 1. 0 means that this direction will be looped over grid vertices, while 1 means that it will be looped over cell centers.
  \item \texttt{F}: The type signature of the lambda function passed to the loop. It is not required to be set explicitly and is automatically deduced by the compiler.
\end{enumerate}

Note that centering indexes can be mixed: setting the indices to $(1,0,0)$, for instance, creates loops over faces on the \texttt{x} direction. Function parameter meanings are as follows:

\begin{enumerate}
  \item \texttt{group\_nghostzones}: The number of ghost zones in each direction of the grid. This can be obtained by calling \texttt{grid.nghostzones}.
  \item \texttt{f}: The \texttt{C++} lambda to be executed on each step of the loop.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loop Lambdas}

We shall now discuss the syntax and the available elements of the lambda functions that are to be fed to the Loop methods described in Section \ref{sec:loop_methods}.

To start, let us be reminded of the general syntax of a lambda function in \texttt{C++}:

\begin{lstlisting}
  // append ; if assigning to a variable
  [capture_parameter] (argument_list) -> return_type { function_body }
\end{lstlisting}

When running on GPUs, the \texttt{capture\_parameter} field used should always be \texttt{=}, indicating pass by value (copy) rather than \texttt{\&}, indicating pass by reference. The \texttt{argument\_list} of the lambda should receive only one element of type \texttt{PointDesc} (which will be described on Sec.~\ref{sec:point_des}) and the lambda must return no value, which means that \texttt{return\_type} can be omitted altogether.

This means that a typical lambda passed to a loop method will have the form
%
\begin{lstlisting}
  [=] (const Loop::PointDesc &p) {
    // loop body
  }
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \texttt{PointDesc} type and loop lambda body}
\label{sec:point_des}

The \texttt{PointDesc} type provides a complete description of the current grid element in the loop. The following members are the ones that are expected to be used more often:
%
\begin{enumerate}
  \item \texttt{I}: A 3-element array containing the grid point indices.
  \item \texttt{DI}: A 3-element array containing the direction unit vectors from the current grind point.
  \item \texttt{X}: A 3-element array containing the point's coordinates.
  \item \text{DX}: A 3-element array containing the point's grid spacing.
  \item {iter}: The current loop iteration.
\end{enumerate}

In the body of a loop lambda, grid functions declared in the thorn's \texttt{interface.ccl} file are available as \texttt{GF3D2} objects, which are \texttt{C++} wrappers around native \Cactus\space grid functions. These objects are accessible by directly calling them as functions taking arrays of grid indices as input. Such indices, in turn can be obtained by directly accessing \texttt{PointDesc} members.

\subsection{Example: Computing a RHS with finite differences}

Let us now combine the elements describe thus far into a single example. Let us suppose that the following system of PDEs is implemented in \Cactus:

\begin{align}
  \partial_t u & = \rho \label{eq:toy_loop_0}\\
  \partial_t \rho & = \partial_x^2 u + \partial_y^2 u + \partial_z^2 u \label{eq:toy_loop_1}
\end{align}

Let us suppose that the grid functions \texttt{u} and \texttt{rho} where made available, while grid functions \texttt{u\_rhs} and \texttt{rho\_rhs} are their corresponding RHS storage variables. The function that computes the RHS of Eqs.~\eqref{eq:toy_loop_0}-\eqref{eq:toy_loop_1} can be written as

\begin{lstlisting}
extern "C" void LoopExample_RHS(CCTK_ARGUMENTS) {
  DECLARE_CCTK_ARGUMENTS_LoopExample_RHS;
  DECLARE_CCTK_PARAMETERS;

  // The grid variable is implicitly defined via the CCTK macros
  // A 0/1 in template parameters indicate that a grid is vertex/cell centered
  grid.loop_int<0, 0, 0>(
    grid.nghostzones,

    // The loop lambda
    [=] (const Loop::PointDesc &p) {
      using std::pow;

      const CCTK_REAL hx = p.DX[0] * p.dX[0];
      const CCTK_REAL hy = p.DX[1] * p.dX[1];
      const CCTK_REAL hz = p.DX[2] * p.dX[2];
      
      const CCTK_REAL dudx = u(p.I - p.DI[0]) - 2 * u(p.I) 
        + u(p.I + p.DI[0])/hx;

      const CCTK_REAL dudy = u(p.I - p.DI[1]) - 2 * u(p.I) 
        + u(p.I + p.DI[1])/hy;

      const CCTK_REAL dudz = u(p.I - p.DI[2]) - 2 * u(p.I) 
        + u(p.I + p.DI[2])/hz;

      u_rhs(p.I) = rho(p.I);
      rho_rhs(p.I) = ddu;

    } // Ending of the loop lambda
  ); // Ending of the loop_int call
}
\end{lstlisting}

\subsection{SIMD Vectorization of loops}

\todo{See SIMDWaveToyX/src/simdwavetoyx.cxx}
\todo{Do the fused SIMD operations declared in Arith can be used?}